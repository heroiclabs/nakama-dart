/*
 * Copyright Â© 2024 The Nakama Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package main

import (
	"bufio"
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"strings"
	"text/template"
	"unicode"
)

const codeTemplate string = `/* Code generated by nakama/tool/openapi-gen.go. DO NOT EDIT. */

import 'dart:async';
import 'dart:convert';

import 'package:dio/dio.dart';
import 'package:json_annotation/json_annotation.dart';
import 'package:retrofit/retrofit.dart';

part 'rest.g.dart';

{{- range $defname, $definition := .Definitions }}
{{- $classname := $defname | title }}

{{- if isRefToEnum $defname }}

enum {{ $classname }} {
    {{- range $idx, $enum := $definition.Enum }}
    @JsonValue('{{ $enum }}')
    {{ $enum | toLower | snakeToCamel }},
    {{- end }}
}
{{- else }}

/// {{ (descriptionOrTitle $definition.Description $definition.Title) | stripNewlines }}
@JsonSerializable(explicitToJson: true)
class {{ $classname }} {
    {{- range $propname, $property := $definition.Properties }}
    {{- $fieldname := $propname }}
    {{- $attrDataName := $propname | camelToSnake }}
    {{- if eq $propname "refresh_token" }}{{ $fieldname = "refreshToken" }}{{ end }}
    @JsonKey(name: '{{ $attrDataName }}')
    {{- if eq $property.Type "integer" }}
    final int? {{ $fieldname }};
    {{- else if eq $property.Type "number" }}
    final double? {{ $fieldname }};
    {{- else if eq $property.Type "boolean" }}
    final bool? {{ $fieldname }};
    {{- else if eq $property.Type "string" }}
    final String? {{ $fieldname }};
    {{- else if eq $property.Type "array" }}
        {{- if eq $property.Items.Type "string" }}
    final List<String>? {{ $fieldname }};
        {{- else if eq $property.Items.Type "integer" }}
    final List<int>? {{ $fieldname }};
        {{- else if eq $property.Items.Type "number" }}
    final List<double>? {{ $fieldname }};
        {{- else if eq $property.Items.Type "boolean" }}
    final List<bool>? {{ $fieldname }};
        {{- else}}
    final List<{{$property.Items.Ref | cleanRef}}>? {{ $fieldname }};
        {{- end }}
    {{- else if eq $property.Type "object"}}
        {{- if eq $property.AdditionalProperties.Type "string"}}
            {{- if eq $property.AdditionalProperties.Format "int64" }}
    final Map<String, int>? {{ $fieldname }};
    {{- else }}
    final Map<String, String>? {{ $fieldname }};
    {{- end }}
    {{- else if eq $property.AdditionalProperties.Type "integer"}}
    final Map<String, int>? {{ $fieldname }};
    {{- else if eq $property.AdditionalProperties.Type "number"}}
    final Map<String, double>? {{ $fieldname }};
    {{- else if eq $property.AdditionalProperties.Type "boolean"}}
    final Map<String, bool>? {{ $fieldname }};
    {{- else}}
    final Map<String, {{$property.AdditionalProperties.Ref | cleanRef}}>? = {} {{ $fieldname }};
    {{- end}}
    {{- else if isRefToEnum (cleanRef $property.Ref) }}
    final {{ $property.Ref | cleanRef }}? {{ $fieldname }};
    {{- else }}
    final {{ $property.Ref | cleanRef }}? {{ $fieldname }};
    {{- end }}
    {{- end }}
    
    const {{ $classname }}({
        {{- $first := true -}}
        {{- range $propname, $property := $definition.Properties }}
        {{- $fieldname := $propname }}
        {{- $attrDataName := $propname | camelToSnake }}
        {{- if eq $propname "refresh_token" }}{{ $fieldname = "refreshToken" }}{{ end }}
        {{- if eq $property.Type "integer" }}
        required this.{{ $fieldname }}
        {{- else if eq $property.Type "number" }}
        required this.{{ $fieldname }}
        {{- else if eq $property.Type "boolean" }}
        required this.{{ $fieldname }}
        {{- else if eq $property.Type "string" }}
        required this.{{ $fieldname }}
        {{- else if eq $property.Type "array" }}
            {{- if eq $property.Items.Type "string" }}
        required this.{{ $fieldname }}
            {{- else if eq $property.Items.Type "integer" }}
        required this.{{ $fieldname }}
            {{- else if eq $property.Items.Type "number" }}
        required this.{{ $fieldname }}
            {{- else if eq $property.Items.Type "boolean" }}
        required this.{{ $fieldname }}
            {{- else}}
        required this.{{ $fieldname }}
            {{- end }}
        {{- else if eq $property.Type "object"}}
            {{- if eq $property.AdditionalProperties.Type "string"}}
                {{- if eq $property.AdditionalProperties.Format "int64" }}
        required this.{{ $fieldname }}
        {{- else }}
        required this.{{ $fieldname }}
        {{- end }}
        {{- else if eq $property.AdditionalProperties.Type "integer"}}
        required this.{{ $fieldname }}
        {{- else if eq $property.AdditionalProperties.Type "number"}}
        required this.{{ $fieldname }}
        {{- else if eq $property.AdditionalProperties.Type "boolean"}}
        required this.{{ $fieldname }}
        {{- else}}
        required this.{{ $fieldname }}
        {{- end}}
        {{- else if isRefToEnum (cleanRef $property.Ref) }}
        required this.{{ $fieldname }}
        {{- else }}
        required this.{{ $fieldname }}
        {{- end }},
        {{- end }}
    });

    factory {{ $classname }}.fromJson(Map<String, dynamic> json) => _${{ $classname }}FromJson(json);

    Map<String, dynamic> toJson() => _${{ $classname }}ToJson(this);

    @override
    String toString() => jsonEncode(this);
}
{{- end }}
{{- end }}


/// The low level client for the {{ .Namespace }} API.
@RestApi()
abstract class ApiClient
{
    factory ApiClient(Dio dio, {String baseUrl}) = _ApiClient;

    {{- range $url, $path := .Paths }}
    {{- range $method, $operation := $path}}

    /// {{ $operation.Summary | stripNewlines }}
    @{{ $method | uppercase }}('{{ $url }}')
    Future<{{- if $operation.Responses.Ok.Schema.Ref }}{{ $operation.Responses.Ok.Schema.Ref | cleanRef }}{{- else }}void {{- end }}> {{ $operation.OperationId | stripOperationPrefix | snakeToCamel }}({
    

    {{- if $operation.Security }}
        {{- range $idx, $security := $operation.Security}}
            {{- range $key, $value := $security}}
                {{- if or (eq $key "BasicAuth") (eq $key "HttpKeyAuth") }}
        String? basicAuthUsername,
        String? basicAuthPassword,
        String? bearerToken,
                {{- end }}
            {{- end }}
        {{- end }}
    {{- else }}
        String? bearerToken,
    {{- end }}

    {{- range $parameter := $operation.Parameters }}

    {{- if eq $parameter.In "path" }}
        @Path('{{ $parameter.Name }}'){{ if $parameter.Required }}required{{- end}} {{ $parameter.Type | camelToPascal }}{{- if not $parameter.Required }}?{{- end }} {{ $parameter.Name }},
    {{- else if eq $parameter.In "body" }}
        {{- if eq $parameter.Schema.Type "string" }}
        @Body() {{ if $parameter.Required }}required{{- end}} String{{- if not $parameter.Required }}?{{- end }} {{ $parameter.Name }},
        {{- else }}
        @Body() {{ if $parameter.Required }}required {{ end }}{{ $parameter.Schema.Ref | cleanRef }}{{- if not $parameter.Required }}?{{- end }} {{ $parameter.Name }},
        {{- end }}
	{{- else if eq $parameter.In "query" }}
		@Query('{{ $parameter.Name }}')
    {{- if eq $parameter.Type "array"}}
    		required List<{{ $parameter.Items.Type | camelToPascal }}> {{ $parameter.Name | snakeToCamel }},
    {{- else if eq $parameter.Type "object"}},
        {{- if eq $parameter.AdditionalProperties.Type "string"}}
    required Map<String, String> {{ $parameter.Name }},
        {{- else if eq $parameter.Items.Type "integer"}}
    required Map<String, int> {{ $parameter.Name }},
        {{- else if eq $parameter.Items.Type "boolean"}}
    required Map<String, int> {{ $parameter.Name }},
        {{- else}}
    required Map<String, {{ $parameter.Items.Type }}> {{ $parameter.Name }},
        {{- end}}
    {{- else if eq $parameter.Type "integer" }}
        int? {{ $parameter.Name }},
    {{- else if eq $parameter.Type "boolean" }}
        bool? {{ $parameter.Name }},
    {{- else if eq $parameter.Type "string" }}
        String? {{ $parameter.Name }},
    {{- else }}
        {{ if $parameter.Required }}required{{ end }} {{ $parameter.Type }}{{- if not $parameter.Required }}?{{- end }} {{ $parameter.Name }},
    {{- end }}
	{{- end }}
	{{- end }}
	  });
    {{- end }}
{{- end }}
}
`

func convertRefToClassName(input string) (className string) {
	cleanRef := strings.TrimPrefix(input, "#/definitions/")
	className = strings.Title(cleanRef)
	return
}

// Convert string to lower case.
func toLower(input string) (output string) {
	return strings.ToLower(input)
}

// camelToSnake converts a camel or Pascal case string into snake case.
func camelToSnake(input string) (output string) {
	for k, v := range input {
		if unicode.IsUpper(v) {
			formatString := "%c"

			if k != 0 {
				formatString = "_" + formatString
			}

			output += fmt.Sprintf(formatString, unicode.ToLower(v))
		} else {
			output += string(v)
		}
	}

	return
}

func snakeToCamel(input string) (output string) {
	isToUpper := false
	for k, v := range input {
		if k == 0 {
			output = strings.ToLower(string(input[0]))
		} else {
			if isToUpper {
				output += strings.ToUpper(string(v))
				isToUpper = false
			} else {
				if v == '_' {
					isToUpper = true
				} else if v >= 'A' && v <= 'Z' {
					output += string(v)
					isToUpper = false
				} else {
					output += string(v)
				}
			}
		}
	}
	return
}

func snakeToPascal(input string) (output string) {
	isToUpper := false
	for k, v := range input {
		if k == 0 {
			output = strings.ToUpper(string(input[0]))
		} else {
			if isToUpper {
				output += strings.ToUpper(string(v))
				isToUpper = false
			} else {
				if v == '_' {
					isToUpper = true
				} else {
					output += string(v)
				}
			}
		}
	}
	return
}

func isPropertyEnum(string) (output string) {
	return
}

// pascalToCamel converts a Pascal case string to a camel case string.
func pascalToCamel(input string) (camelCase string) {
	if input == "" {
		return ""
	}

	camelCase = strings.ToLower(string(input[0]))
	camelCase += string(input[1:])
	return camelCase
}

func splitEnumDescription(description string) (output []string) {
	return strings.Split(description, "\n")
}

func stripNewlines(input string) string {
	return strings.Replace(input, "\n", " ", -1)
}

func stripOperationPrefix(input string) string {
	return strings.Replace(input, "Nakama_", "", 1)
}

func descriptionOrTitle(description string, title string) string {
	if description != "" {
		return description
	}

	return title
}

// camelToPascal converts a string from camel case to Pascal case.
func camelToPascal(camelCase string) (pascalCase string) {

	if len(camelCase) <= 0 {
		return ""
	}

	pascalCase = strings.ToUpper(string(camelCase[0])) + camelCase[1:]
	return
}

func main() {
	// Argument flags
	var output = flag.String("output", "", "The output for generated code.")
	flag.Parse()

	inputs := flag.Args()
	if len(inputs) < 1 {
		fmt.Printf("No input file found: %s\n\n", inputs)
		fmt.Println("openapi-gen [flags] inputs...")
		flag.PrintDefaults()
		return
	}

	inputFile := inputs[0]
	content, err := os.ReadFile(inputFile)
	if err != nil {
		fmt.Printf("Unable to read file: %s\n", err)
		return
	}

	var namespace (string) = ""

	if len(inputs) > 1 {
		if len(inputs[1]) <= 0 {
			fmt.Println("Empty Namespace provided.")
			return
		}

		namespace = inputs[1]
	}

	var schema *Schema
	if err := json.Unmarshal(content, &schema); err != nil {
		fmt.Printf("Unable to decode input file %s : %s\n", inputFile, err)
		return
	}
	schema.Namespace = namespace

	generateBodyDefinitionFromSchema(schema)

	fmap := template.FuncMap{
		"snakeToCamel": snakeToCamel,
		"camelToSnake": camelToSnake,
		"cleanRef":     convertRefToClassName,
		"toLower":      toLower,
		"isRefToEnum": func(ref string) bool {
			// swagger schema definition keys have inconsistent casing
			var camelOk bool
			var pascalOk bool
			var enums []string

			asCamel := pascalToCamel(ref)
			if _, camelOk = schema.Definitions[asCamel]; camelOk {
				enums = schema.Definitions[asCamel].Enum
			}

			asPascal := camelToPascal(ref)
			if _, pascalOk = schema.Definitions[asPascal]; pascalOk {
				enums = schema.Definitions[asPascal].Enum
			}

			if !pascalOk && !camelOk {
				fmt.Printf("no definition found: %v", ref)
				return false
			}

			return len(enums) > 0
		},
		"pascalToCamel":        pascalToCamel,
		"snakeToPascal":        snakeToPascal,
		"stripNewlines":        stripNewlines,
		"title":                strings.Title,
		"uppercase":            strings.ToUpper,
		"camelToPascal":        camelToPascal,
		"splitEnumDescription": splitEnumDescription,
		"stripOperationPrefix": stripOperationPrefix,
		"descriptionOrTitle":   descriptionOrTitle,
	}

	tmpl, err := template.New(inputFile).Funcs(fmap).Parse(codeTemplate)
	if err != nil {
		panic(err)
	}

	if len(*output) < 1 {
		tmpl.Execute(os.Stdout, schema)
		return
	}

	f, err := os.Create(*output)
	if err != nil {
		fmt.Printf("Unable to create file: %s\n", err)
		return
	}
	defer f.Close()

	writer := bufio.NewWriter(f)
	tmpl.Execute(writer, schema)
	writer.Flush()
}

type Schema struct {
	Namespace string
	Paths     map[string]map[string]struct {
		Summary     string
		OperationId string
		Responses   struct {
			Ok struct {
				Schema struct {
					Ref string `json:"$ref"`
				}
			} `json:"200"`
		}
		Parameters []struct {
			Name     string
			In       string
			Required bool
			Type     string   // used with primitives
			Items    struct { // used with type "array"
				Type string
			}
			Format string       // used with type "boolean"
			Schema ObjectSchema `json:"schema"`
		}
		Security []map[string][]struct {
		}
	}
	Definitions map[string]ObjectDefinition
}

type ObjectSchema struct {
	Type       string
	Ref        string `json:"$ref"`
	Properties map[string]struct {
		Type        string
		Description string
	}
	Description string
}

type ObjectDefinition struct {
	Properties map[string]ObjectProperty

	Enum        []string
	Description string
	// used only by enums
	Title string
}

type ObjectProperty struct {
	Type                 string
	Ref                  string `json:"$ref"` // used with object
	Items                Items
	AdditionalProperties AdditionalProperties
	Format               string // used with type "boolean"
	Description          string
	Title                string // used by enums
}

type Items struct {
	Type string
	Ref  string `json:"$ref"`
}

type AdditionalProperties struct {
	Type   string // used with type "map"
	Format string // used with type "map"
	Ref    string `json:"$ref"` // used with object
}

func generateBodyDefinitionFromSchema(s *Schema) {
	// Needed because of this change: https://github.com/grpc-ecosystem/grpc-gateway/issues/1670
	for _, def := range s.Paths {
		if verb, ok := def["put"]; ok {
			for idx, param := range verb.Parameters {
				if param.In == "body" && param.Name == "body" && param.Schema.Ref == "" {
					objectName := "Api" + strings.TrimPrefix(verb.OperationId, fmt.Sprintf("%s_", s.Namespace)) + "Request"
					param.Schema.Ref = "#/definitions/" + objectName
					def["put"].Parameters[idx] = param

					properties := make(map[string]ObjectProperty)
					for key, p := range param.Schema.Properties {
						properties[key] = ObjectProperty{
							Type:                 p.Type,
							Items:                Items{},
							AdditionalProperties: AdditionalProperties{},
							Description:          p.Description,
						}
					}

					s.Definitions[objectName] = ObjectDefinition{
						Properties:  properties,
						Description: param.Schema.Description,
					}
				}
			}
		}
	}
}
